###1.静态加载左侧菜单

```
<el-menu :default-openeds="['1', '3']":default-active="'1-1'">
 <!--导航1-->
 <!--el-submenu：可以展开的菜单栏，常用属性-->
 <!--index：菜单的下标，文本类型，不能是数值类型。-->
  <el-submenu index="1">
    <!--template：对应el-submenu的菜单名-->
    <!--i:设置菜单图标，通过class属性实则-->
    <!--常用的elment-ui中自带的图标el-icon-message/el-icon-menu/el-icon-setting-->
    <template slot="title"><i class="el-icon-message"></i>导航一</template>
   <!--el-menu-item-group：分组属性，可用可不要-->
    <el-menu-item-group>
      <template slot="title">分组一</template>
      <!--el-menu-item：菜单的子节点，不可再展开-->
      <!--常用属性index：菜单的下标，文本类型，不能是数值类型。&ndash;&gt;-->
      <el-menu-item index="1-1">选项1</el-menu-item>
      <el-menu-item index="1-2">选项2</el-menu-item>
    </el-menu-item-group>
    <el-menu-item-group title="分组2">
      <el-menu-item index="1-3">选项3</el-menu-item>
    </el-menu-item-group>
    <el-submenu index="1-4">
      <template slot="title">选项4</template>
      <el-menu-item index="1-4-1">选项4-1</el-menu-item>
    </el-submenu>
  </el-submenu>
</el-menu>
```

###2.VUE router 来动态构建左侧菜单

- 导航1

  - 页面1
  - 页面2

- 导航2

  - 页面3

  - 页面4




###3.   4.13笔记

块级标签不能同行，转换成行级标签display：inclin-block



###4.弹窗组件

```
<el-button type="text" @click="centerDialogVisible = true">点击打开 Dialog</el-button>

<el-dialog
  title="提示"
  :visible.sync="centerDialogVisible"
  width="30%"
  center>
  <span>需要注意的是内容是默认不居中的</span>
  <span slot="footer" class="dialog-footer">
    <el-button @click="centerDialogVisible = false">取 消</el-button>
    <el-button type="primary" @click="centerDialogVisible = false">确 定</el-button>
  </span>
</el-dialog>

<script>
  export default {
    data() {
      return {
        centerDialogVisible: false
      };
    }
  };
</script>
```



###5.高德地图组件安装

使用插件: vue-amap

（1）npm安装vue-amap

npm install vue-amap --save



### 6.弹窗组件dialog封装

- 子组件接收父组件传值用props属性
- 子组件给父组件弹指用自定义事件法
- 父组件给子组件传值是单向的，子组件想给父组件传值需要自定义事件




### 7.引入视频播放器组件

参考CSDN

https://blog.csdn.net/qq_38128179/article/details/102959762?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_utm_term-8&spm=1001.2101.3001.4242

##### 第一步：安装

`npm install vue-video-player --save`    

##### 第二步：引入组件

（1）`main.js`中全局引入

```
import VideoPlayer from 'vue-video-player'
import 'vue-video-player/src/custom-theme.css'
import 'video.js/dist/video-js.css'
 
Vue.use(VideoPlayer)

```

（2）组件引用

```
import { videoPlayer } from 'vue-video-player'
import 'video.js/dist/video-js.css'
 
export default {
  components: {
    videoPlayer
  }
}
```

##### 第三步：配置

（1）.html部分

```
<template>
    <div class='demo'>
      <video-player class="video-player vjs-custom-skin" 
            ref="videoPlayer" 
            :playsinline="true" 
            :options="playerOptions">
      </video-player>
    </div>
</template>
```

（2）js部分配置

```
export default {
data() {
    return {
     playerOptions: {
        playbackRates: [0.5, 1.0, 1.5, 2.0], // 可选的播放速度
        autoplay: false, // 如果为true,浏览器准备好时开始回放。
        muted: false, // 默认情况下将会消除任何音频。
        loop: false, // 是否视频一结束就重新开始。
        preload: 'auto', // 建议浏览器在<video>加载元素后是否应该开始下载视频数据。auto浏览器选择最佳行为,立即开始加载视频（如果浏览器支持）
        language: 'zh-CN',
        aspectRatio: '16:9', // 将播放器置于流畅模式，并在计算播放器的动态大小时使用该值。值应该代表一个比例 - 用冒号分隔的两个数字（例如"16:9"或"4:3"）
        fluid: true, // 当true时，Video.js player将拥有流体大小。换句话说，它将按比例缩放以适应其容器。
        sources: [{
          type: "video/mp4", // 类型
          src: '' // url地址
        }],
        poster: '', // 封面地址
        notSupportedMessage: '此视频暂无法播放，请稍后再试', // 允许覆盖Video.js无法播放媒体源时显示的默认信息。
        controlBar: {
          timeDivider: true, // 当前时间和持续时间的分隔符
          durationDisplay: true, // 显示持续时间
          remainingTimeDisplay: false, // 是否显示剩余时间功能
          fullscreenToggle: true // 是否显示全屏按钮
            }
          }
        }
      }
    }
```

##### 第四：视频格式

```
type："video/webm"   // 可以播放，用ogg也可打开
type："video/ogg"    // 可以播放，用webm也可打开
type："video/3gp"    // 可以播放
type："video/mp4"    // 可以播放
type："video/avi"    // 打不开
type："video/flv"    // 打不开
type："video/mkv"    // 打不开
type："video/mov"    // 打不开
type："video/mpg"    // 打不开
type："video/swf"    // 打不开
type："video/ts"     // 打不开
type："video/wmv"    // 打不开
type："video/vob"    // 没转化
type："video/mxf"    // 转化出错
type: "video/rm"     // 转化出错
```

##### 第五：其他配置

```
this.$refs.videoPlayer.player.play() // 播放
this.$refs.videoPlayer.player.pause() // 暂停
this.$refs.videoPlayer.player.src(src) // 重置进度条
```

##### 第六：回调函数

```
<template>
<div class='demo'>
<video-player class="video-player vjs-custom-skin" 
        ref="videoPlayer" 
        :playsinline="true" 
        :options="playerOptions"
        @play="onPlayerPlay($event)" 
        @pause="onPlayerPause($event)"
        @ended="onPlayerEnded($event)"
        @waiting="onPlayerWaiting($event)"
        @playing="onPlayerPlaying($event)"
        @loadeddata="onPlayerLoadeddata($event)"
        @timeupdate="onPlayerTimeupdate($event)"
        @canplay="onPlayerCanplay($event)"
        @canplaythrough="onPlayerCanplaythrough($event)"
        @statechanged="playerStateChanged($event)"
        @ready="playerReadied"
      >
</video-player>
</div>
</template>
 
<script>
    export default {
      methods: {
        // 播放回调
        onPlayerPlay(player) {
          console.log('player play!', player)
        },
 
        // 暂停回调
        onPlayerPause(player) {
          console.log('player pause!', player)
        },
 
        // 视频播完回调
        onPlayerEnded($event) {
          console.log(player)
        },
 
        // DOM元素上的readyState更改导致播放停止
        onPlayerWaiting($event) {
          console.log(player)
        },
 
        // 已开始播放回调
        onPlayerPlaying($event) {
          console.log(player)
        },
 
        // 当播放器在当前播放位置下载数据时触发
        onPlayerLoadeddata($event) {
          console.log(player)
        },
 
        // 当前播放位置发生变化时触发。
        onPlayerTimeupdate($event) {
          console.log(player)
        },
 
        //媒体的readyState为HAVE_FUTURE_DATA或更高
        onPlayerCanplay(player) {
          // console.log('player Canplay!', player)
        },
 
        //媒体的readyState为HAVE_ENOUGH_DATA或更高。这意味着可以在不缓冲的情况下播放整个媒体文件。
        onPlayerCanplaythrough(player) {
          // console.log('player Canplaythrough!', player)
        },
 
        //播放状态改变回调
        playerStateChanged(playerCurrentState) {
          console.log('player current update state', playerCurrentState)
        },
 
        //将侦听器绑定到组件的就绪状态。与事件监听器的不同之处在于，如果ready事件已经发生，它将立即触发该函数。。
        playerReadied(player) {
          console.log('example player 1 readied', player);
        }
        
      },
    }
 </script>
```



### 8.嵌套路由





### 9.字符

- 空格&nbsp






### 10.系统权限管理

根据用户的权限不同，所能看到的页面和可操作性不同

admin-所有页面都可以看到

vip-属于vip的权限等



准备动态加载的路由

addRouter()


